<objdefs appVersion="1.0.12">
   <obj.normal id="midichordIN" uuid="047d6a7e-d193-465c-b0ba-cf2c4e04499e">
      <sDescription>Receives 3 notes (triad) with pitchbend offset.
To be used with the pythagorean tonnetz sequencer and &quot;midichordOUT&quot; modules.
This way the frequencies being generated by the tonnetz sequencer can also be send to external boards.
This module outputs note-values instead of the frequency input values of the &quot;midichordOUT&quot; module.</sDescription>
      <author>Remco van der Most</author>
      <license>BSD</license>
      <helpPatch>midi_in.axh</helpPatch>
      <inlets/>
      <outlets>
         <frac32 name="n1"/>
         <frac32 name="n2"/>
         <frac32 name="n3"/>
      </outlets>
      <displays/>
      <params>
         <bool32.tgl name="singleOctave" noLabel="true"/>
      </params>
      <attribs>
         <spinner name="ccl" MinValue="0" MaxValue="127" DefaultValue="64"/>
         <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="0"/>
      </attribs>
      <code.declaration><![CDATA[int32_t note[3];
int32_t bend[3];
int cnt;
int32_t bendl;
bool ntrig;
bool singleOct;]]></code.declaration>
      <code.init><![CDATA[cnt=2;
bendl=0;
for(int i=0;i<3;i++){
	note[i]=0;
	bend[i]=0;
}]]></code.init>
      <code.krate><![CDATA[outlet_n1=note[0]+(bend[0]>>7);
outlet_n2=note[1]+(bend[1]>>7);
outlet_n3=note[2]+(bend[2]>>7);
singleOct=param_singleOctave;]]></code.krate>
      <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + attr_channel-1)&&data2){
cnt+=1;
cnt=cnt>2?0:cnt;

note[cnt]=data1-64;
if(singleOct>0){
note[cnt]=note[cnt]-note[cnt]/12*12+(note[cnt]<0?12:0);
}
note[cnt]=note[cnt]<<21;
}


if (status == MIDI_PITCH_BEND + attr_channel-1) {  bend[cnt] = (((int)((data2<<7)+data1)-0x2000)<<14) + bendl;
ntrig=0;
} else if ((status == attr_channel-1 + MIDI_CONTROL_CHANGE) && (data1 == attr_ccl)) {
   bendl = data2 << 7;
}]]></code.midihandler>
   </obj.normal>
</objdefs>