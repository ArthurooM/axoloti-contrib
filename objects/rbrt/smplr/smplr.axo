<objdefs appVersion="1.0.12">
   <obj.normal id="smplr" uuid="a62a5ad5-5a20-4c68-9b42-0be212460d50">
      <sDescription>edits a bank of samples recorded with &apos;smplr&apos;.
&apos;slot&apos; sets the slot to work on,
&apos;copy&apos;,&apos;move&apos; and &apos;delete&apos; have to be triggered via &apos;trig&apos;.
&apos;defrag&apos; will clear unused sample data and compact the referred table.
&apos;clear&apos; will clear the data.</sDescription>
      <author>Robert Schirmer</author>
      <license>BSD</license>
      <helpPatch>smplr.axh</helpPatch>
      <inlets>
         <int32.positive name="slot" description="slot to work on"/>
         <bool32.rising name="copy"/>
         <bool32.rising name="paste"/>
         <bool32.rising name="delete"/>
         <bool32 name="pitchUp"/>
         <bool32 name="pitchDown"/>
         <bool32.rising name="defrag" description="defragment the sample data"/>
         <bool32.rising name="clear" description="clear all data"/>
      </inlets>
      <outlets>
         <bool32.pulse name="delete" description="pulse on delete"/>
         <int32 name="test"/>
      </outlets>
      <displays/>
      <params/>
      <attribs>
         <objref name="wave"/>
      </attribs>
      <code.declaration><![CDATA[static const uint32_t LENGTHPOW = 12;
static const uint32_t LENGTH = 1<<12;
static const uint32_t LENGTHMASK = (1<<12)-1;
static const uint32_t BITS = 32;
static const uint32_t GAIN = 0;
uint32_t *array;
#define WAVE attr_wave.array 
#define W_GAIN attr_wave.GAIN
#define W_LENGTH attr_wave.LENGTH

uint32_t global[16];
#define GLOBAL global
#define REC_HEAD global[15]
#define TEMPO global[0]

uint32_t *del_array;
uint16_t delcount;

bool REC;
uint8_t RECSLOT;
uint8_t SHIFT;

bool ctrig;
bool dtrig;
bool ptrig;
bool del;
bool clrtrig;
uint8_t mslot;
uint8_t srcslot;

uint32_t sstart;
uint32_t send;
uint32_t slength;

int32_t paramtemp [32];


void delete_slot (uint8_t target)__attribute__((noinline))  {
	uint16_t adr = target << 5;
	int check = 1;
	if (array [adr + 30]){
	int start = array[adr + 28];
	int end = array[adr + 29];
	int i;
	for (i = 0;i < 32;i++) array [adr + i ] = 0;
		for (i = 0;i < 127; i ++) if (array [(i << 5) + 29] == end) check = 0;
	if (check) {
		del_array [delcount] = start;
		del_array [delcount + 1] = end;
		delcount +=2;
		}
	}	
}

void defrag ()__attribute__((noinline)){
		int i;
	for (i = 0; i < delcount;i+=2){		
		sstart = del_array [i];
		send =  del_array[i + 1];	
		slength = (send - sstart);			
				int shift_index;
				for(shift_index=0;shift_index < LENGTH;shift_index += 32)
				if (array[shift_index + 28] >= send) {
					array[shift_index + 28] -= slength;
					array[shift_index + 29] -= slength;
					}			
				int move_samples;
				for(move_samples=send;move_samples < REC_HEAD;move_samples++) 
				WAVE [move_samples - slength] = WAVE[move_samples];							
				int shift_chunks;
				for (shift_chunks = 0;shift_chunks < delcount;shift_chunks += 2)
				if (array[shift_chunks] >= send ) {array [shift_chunks] -=slength;array [shift_chunks+1] -= slength;}
				REC_HEAD -= slength;	
	}
	delcount = 0;
}]]></code.declaration>
      <code.init><![CDATA[static uint32_t _array[attr_poly][LENGTH]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];

{
	int i;
	for(i=0;i<LENGTH;i++) array[i]=0;
}

static uint32_t _del_array[attr_poly][512]  __attribute__ ((section (".sdram")));
del_array = &_del_array[parent->polyIndex][0];

{
	int i;
	for(i=0;i<512;i++) del_array[i]=0;
}

SHIFT =  (27-attr_wave.LENGTHPOW);]]></code.init>
      <code.krate><![CDATA[mslot = inlet_slot % 128;
outlet_delete = 0;

//delete
if (inlet_delete && !dtrig) {
dtrig = 1;
delete_slot (mslot);
outlet_delete = 1;
}
//defrag
if (inlet_defrag && !ctrig) {
	ctrig = 1;
	defrag();
}
if (!inlet_defrag) ctrig = 0;

//paste
	if (inlet_paste && !ptrig){
	ptrig = 1;
	//pitch up/down
	if (inlet_pitchUp) paramtemp[0] += (((1 << 23)/3)+1);
	if (inlet_pitchDown) paramtemp[0] -= (((1 << 23)/3)+1);
	int i;
	for (i = 0;i < 32 ;i ++ ) array [(mslot * 32)+ i] = paramtemp[i];
	}

//copy	
if (inlet_copy && !ctrig){
	ctrig = 1;
	srcslot = mslot;
	int i;
	for (i = 0;i < 32 ;i ++ ) paramtemp [i] = array [(mslot * 32)+ i];
}

//clear
if (inlet_clear && !clrtrig){
	clrtrig = 1;
	delcount = 0;
	REC_HEAD = 0;
	int i;
	for (i = 0;i < LENGTH;i++)array[i] = 0;
}
	
if (!inlet_copy) ctrig = 0;
if (!inlet_delete) dtrig = 0;
if (!inlet_paste) ptrig = 0;
if (!inlet_clear) clrtrig = 0;]]></code.krate>
   </obj.normal>
</objdefs>